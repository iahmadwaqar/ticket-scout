import { logger } from '../../utils/logger-service.js'
import { profileStore } from '../profile/profileStore.js'
import { ticketMonitoringEngine } from '../monitoring/ticket-engine.js'
import { sessionBridgeService } from '../gologin/session-bridge.js'
import { PROFILE_STATUSES } from '../../../shared/status-constants.js'

/**
 * Ticket Monitoring Integration Service
 * Bridges the monitoring engine with the existing profile bot structure
 * Provides high-level interface for starting/stopping ticket monitoring
 */
export class TicketMonitoringIntegration {
  constructor() {
    this.monitoringProfiles = new Map() // profileId -> monitoring info
  }

  /**
   * Start ticket monitoring for a profile
   * @param {string} profileId - Profile ID
   * @param {Object} config - Monitoring configuration
   * @returns {Promise<Object>} Start result
   */
  async startTicketMonitoring(profileId, config = {}) {
    try {
      logger.info(profileId, 'Starting ticket monitoring integration')

      // Validate profile exists and is ready
      const profile = profileStore.getProfile(profileId)
      if (!profile) {
        throw new Error(`Profile ${profileId} not found`)
      }

      // Check if monitoring is already active
      if (this.monitoringProfiles.has(profileId)) {
        logger.warn(profileId, 'Monitoring already active, stopping previous instance')
        await this.stopTicketMonitoring(profileId)
      }

      // Ensure browser instances are available
      const instances = profileStore.getGoLoginInstances(profileId)
      if (!instances?.cdp) {\n        throw new Error('No browser instance found - profile must be launched first')\n      }\n\n      // Create HTTP session from browser\n      const sessionResult = await sessionBridgeService.createSessionFromBrowser(profileId, {\n        timeout: config.requestTimeout || 30000\n      })\n\n      if (!sessionResult.success) {\n        throw new Error(`Failed to create session: ${sessionResult.error}`)\n      }\n\n      // Prepare monitoring configuration\n      const monitoringConfig = {\n        speedLimit: config.speedLimit || '1',\n        seatCount: config.seatCount || profile.seats || 1,\n        selectedAreas: config.selectedAreas || profile.browserData?.areaIds || [],\n        selectedType: config.selectedType || 'All',\n        keyword1: config.keyword1 || profile.browserData?.keyword1 || '',\n        ...config\n      }\n\n      // Update profile status\n      profileStore.updateStatus(profileId, PROFILE_STATUSES.STARTING)\n      profileStore.updateProfileField(profileId, 'operationalState', 'preparing')\n\n      // Start monitoring engine\n      const monitoringResult = await ticketMonitoringEngine.startMonitoring(\n        profileId,\n        sessionResult.session,\n        monitoringConfig\n      )\n\n      if (!monitoringResult.success) {\n        throw new Error(`Failed to start monitoring: ${monitoringResult.error}`)\n      }\n\n      // Store monitoring info\n      this.monitoringProfiles.set(profileId, {\n        profileId,\n        startedAt: new Date(),\n        config: monitoringConfig,\n        sessionInfo: sessionResult\n      })\n\n      // Update profile status to active monitoring\n      profileStore.updateStatus(profileId, PROFILE_STATUSES.SEARCHING_TICKETS)\n      profileStore.updateProfileField(profileId, 'operationalState', 'monitoring')\n\n      logger.info(profileId, 'Ticket monitoring started successfully')\n\n      return {\n        success: true,\n        message: 'Ticket monitoring started successfully',\n        profileId,\n        config: monitoringConfig\n      }\n\n    } catch (error) {\n      logger.error(profileId, `Failed to start ticket monitoring: ${error.message}`)\n      \n      // Update profile status to error\n      profileStore.updateStatus(profileId, PROFILE_STATUSES.ERROR)\n      profileStore.updateProfileField(profileId, 'errorMessage', error.message)\n\n      return {\n        success: false,\n        error: error.message,\n        profileId\n      }\n    }\n  }\n\n  /**\n   * Stop ticket monitoring for a profile\n   * @param {string} profileId - Profile ID\n   * @returns {Promise<Object>} Stop result\n   */\n  async stopTicketMonitoring(profileId) {\n    try {\n      logger.info(profileId, 'Stopping ticket monitoring')\n\n      // Stop monitoring engine\n      ticketMonitoringEngine.stopMonitoring(profileId)\n\n      // Close session\n      sessionBridgeService.closeSession(profileId)\n\n      // Remove from tracking\n      this.monitoringProfiles.delete(profileId)\n\n      // Update profile status\n      profileStore.updateStatus(profileId, PROFILE_STATUSES.STOPPED)\n      profileStore.updateProfileField(profileId, 'operationalState', 'idle')\n\n      logger.info(profileId, 'Ticket monitoring stopped')\n\n      return {\n        success: true,\n        message: 'Ticket monitoring stopped',\n        profileId\n      }\n\n    } catch (error) {\n      logger.error(profileId, `Failed to stop ticket monitoring: ${error.message}`)\n      return {\n        success: false,\n        error: error.message,\n        profileId\n      }\n    }\n  }\n\n  /**\n   * Check if profile is currently monitoring\n   * @param {string} profileId - Profile ID\n   * @returns {boolean} True if monitoring\n   */\n  isMonitoring(profileId) {\n    return this.monitoringProfiles.has(profileId)\n  }\n\n  /**\n   * Get monitoring status for a profile\n   * @param {string} profileId - Profile ID\n   * @returns {Object|null} Monitoring status or null\n   */\n  getMonitoringStatus(profileId) {\n    const monitoringInfo = this.monitoringProfiles.get(profileId)\n    if (!monitoringInfo) {\n      return null\n    }\n\n    const engineStatus = ticketMonitoringEngine.getMonitoringStatus(profileId)\n    \n    return {\n      profileId,\n      isActive: !!engineStatus?.isRunning,\n      startedAt: monitoringInfo.startedAt,\n      config: monitoringInfo.config,\n      hitCount: engineStatus?.counter || 0,\n      sessionInfo: monitoringInfo.sessionInfo\n    }\n  }\n\n  /**\n   * Update monitoring configuration for a profile\n   * @param {string} profileId - Profile ID  \n   * @param {Object} newConfig - New configuration\n   * @returns {Object} Update result\n   */\n  updateMonitoringConfig(profileId, newConfig) {\n    try {\n      const monitoringInfo = this.monitoringProfiles.get(profileId)\n      if (!monitoringInfo) {\n        throw new Error('Profile is not currently monitoring')\n      }\n\n      // Update stored config\n      monitoringInfo.config = { ...monitoringInfo.config, ...newConfig }\n      \n      // The monitoring engine will pick up changes on next refresh cycle\n      logger.info(profileId, 'Monitoring configuration updated')\n\n      return {\n        success: true,\n        message: 'Configuration updated',\n        profileId,\n        config: monitoringInfo.config\n      }\n\n    } catch (error) {\n      logger.error(profileId, `Failed to update monitoring config: ${error.message}`)\n      return {\n        success: false,\n        error: error.message,\n        profileId\n      }\n    }\n  }\n\n  /**\n   * Stop all monitoring instances\n   * @returns {Promise<Object>} Stop all result\n   */\n  async stopAllMonitoring() {\n    try {\n      logger.info('Global', 'Stopping all ticket monitoring')\n\n      const profileIds = Array.from(this.monitoringProfiles.keys())\n      const results = []\n\n      for (const profileId of profileIds) {\n        const result = await this.stopTicketMonitoring(profileId)\n        results.push(result)\n      }\n\n      // Stop monitoring engine\n      ticketMonitoringEngine.stopAllMonitoring()\n\n      // Close all sessions\n      sessionBridgeService.closeAllSessions()\n\n      logger.info('Global', `Stopped monitoring for ${profileIds.length} profiles`)\n\n      return {\n        success: true,\n        message: `Stopped monitoring for ${profileIds.length} profiles`,\n        results\n      }\n\n    } catch (error) {\n      logger.error('Global', `Failed to stop all monitoring: ${error.message}`)\n      return {\n        success: false,\n        error: error.message\n      }\n    }\n  }\n\n  /**\n   * Get monitoring statistics\n   * @returns {Object} Monitoring stats\n   */\n  getMonitoringStats() {\n    const activeProfiles = Array.from(this.monitoringProfiles.keys())\n    const engineStats = activeProfiles.map(profileId => \n      ticketMonitoringEngine.getMonitoringStatus(profileId)\n    ).filter(Boolean)\n\n    return {\n      totalActiveProfiles: activeProfiles.length,\n      activeProfiles,\n      totalHitCount: engineStats.reduce((sum, stat) => sum + (stat.counter || 0), 0),\n      sessionStats: sessionBridgeService.getSessionStats()\n    }\n  }\n\n  /**\n   * Validate monitoring prerequisites for a profile\n   * @param {string} profileId - Profile ID\n   * @returns {Object} Validation result\n   */\n  validateMonitoringPrerequisites(profileId) {\n    const issues = []\n\n    // Check profile exists\n    const profile = profileStore.getProfile(profileId)\n    if (!profile) {\n      issues.push('Profile not found')\n      return { isValid: false, issues }\n    }\n\n    // Check browser instances\n    const instances = profileStore.getGoLoginInstances(profileId)\n    if (!instances?.cdp) {\n      issues.push('No browser instance found - profile must be launched first')\n    }\n\n    // Check required profile data\n    if (!profile.eventId) {\n      issues.push('Profile missing event ID')\n    }\n\n    if (!profile.matchUrl) {\n      issues.push('Profile missing match URL')\n    }\n\n    if (!profile.browserData) {\n      issues.push('Profile missing browser data')\n    }\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      profile\n    }\n  }\n}\n\n// Export singleton instance\nexport const ticketMonitoringIntegration = new TicketMonitoringIntegration()